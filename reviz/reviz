#!/usr/local/bin/ruby

# reviz is a CGI program which browse CVS repository like ViewCVS or cvsweb.

require 'reviz-conf.rb'

require 'cvs'
require 'cgi'
require 'rsp'

class ReViz
  StickyParameter = {
    'cvsroot' => CVSROOT_LIST[0][0],
    'hideattic' => nil,
    'sortby' => nil,
    'logsort' => nil,
    'diff_format' => nil,
    'only_with_tag' => nil,
  }

  def initialize
    @cgi = CGI.new
  end

  def error(msg)
    @cgi.out("text/plain") {msg}
    exit 0
  end

  def init_cvsroot
    d = @cgi['cvsroot']
    if d.empty?
      cvsroot = CVSROOT_LIST[0][1]
    elsif (d = CVSROOT_LIST.assoc(d[0]))
      cvsroot = d[1]
    else
      error("unknown cvsroot")
    end
    @cvsroot = CVS.create(cvsroot)


    path_info = (@cgi.path_info || '/')
    path = []
    path_info.scan(/[^\/]+/) {|name|
      next if name == '.' || name == '..'
      path << name
    }

    @cvsdir = @cvsroot.top_dir
    @cvsfile = nil
    if path_info =~ /\/\z/
      path.each {|name| @cvsdir = @cvsdir.simple_dir(name)}
    else
      path[0..-2].each {|name| @cvsdir = @cvsdir.simple_dir(name)}
      @cvsfile = @cvsdir.simple_file(path[-1])
    end
  end

  def init_url
    @url_base = @cgi.script_name || 'reviz.cgi'
    @url_params = {}
    StickyParameter.each {|k,v|
      if @cgi.has_key? k
	@url_params[k] = @cgi[k][0]
      else
	@url_params[k] = v
      end
    }
  end

  def url(path_info, extra_params={}, fragment=nil)
    params = @url_params.dup
    if extra_params
      extra_params.each {|k,v|
	if v == nil
	  params.delete(k)
	else
	  params[k] = v
	end
      }
    end
    StickyParameter.each {|k,v|
      params.delete(k) if params[k] == v
    }

    result = @url_base.dup
    if path_info
      result << '/' << path_info
    end
    unless params.empty?
      result << '?' << params.keys.sort.collect {|k|
                         "#{k}=#{CGI::escape(params[k])}"
		       }.join('&')
    end
    if fragment != nil
      result << '#' << fragment
    end
    return result
  end

  def main
    errortrap {
      init_cvsroot
      init_url

      if !@cgi.path_info
        list_repository
      elsif @cvsfile
	if @cgi.has_key? 'rev'
	  view_checkout(CVS::Revision.create(@cgi['rev'][0]))
	elsif @cgi.has_key? 'annotate'
	  view_annotate(CVS::Revision.create(@cgi['annotate'][0]))
	else
	  view_log
	end
      else
	view_directory
      end
    }
  end

  def errortrap
    @cgi_options = {'type' => 'text/html'}
    begin
      contents = yield
    rescue
      ex = $!
      @cgi.print @cgi.header('text/plain')
      @cgi.print ex.to_s, "\n"
      ex.backtrace.each {|s|
        @cgi.print s, "\n"
      }
      @cgi.print "\n"
      return
    end
    @cgi.print @cgi.header(@cgi_options)
    @cgi.print contents
  end

  def list_repository
    return RSP.load("#{RSP_DIR}/list_repositories.rsp").new(
      CVSROOT_LIST.collect {|name, *rest|
	RSP[
	  :name => name,
	  :url => url('', {'cvsroot'=>name})
	]}).gen
  end

  # RevFilter represents subset of revisions.
  class RevFilter
    def RevFilter.create(spec=nil)
      case spec
      when nil
	return All.new
      when String
        case spec
	when 'MAIN'
	  return MainTrunk.new
	when 'HEAD'
	  return Head.new
	end
	begin
	  rev = CVS::Revision.create(spec)
	  return Rev.new(rev)
	rescue CVS::Revision::RevisionError
	  return Tag.new(spec)
	end
      when Revision
	return Rev.new(spec)
      end
      raise RevFilterError.new("unrecognized spec: #{spec.inspect}")
    end
    class RevFilterError < StandardError
    end

    def initialize
      @branch = nil
      @tag = {}
      @revs = []
      @one = nil
    end
    attr_reader :revs, :one

    def head(rev)
      @head = rev
    end

    def branch(rev)
      @branch = rev
    end

    def symbol(sym, rev)
      @tag[sym] = rev
    end

    def revision(rev)
      update_revs(rev)
      update_one(rev)
    end

    def update_revs(rev)
      @revs << rev
    end

    def update_one(rev)
      @one = rev if !@one || @one < rev
    end

    def parse_log_opts_one
      return parse_log_opts_all
    end

    def parse_log_opts_all
      return []
    end

    def attic_sensitive?
      return false
    end

    class All < RevFilter
      def parse_log_opts_one
	return ['-N', '-r']
      end

      def parse_log_opts_all
	return ['-N']
      end

      def update_one(rev)
	super if @branch ? rev.on?(@branch) : rev.on_trunk?
      end

      def attic_sensitive?
	return true
      end
    end

    class MainTrunk < RevFilter
      def parse_log_opts_one
	return ['-N', '-r']
      end

      def parse_log_opts_all
	return ['-N']
      end

      def revision(rev)
	super if @branch ? rev.on?(@branch) : rev.on_trunk?
      end

      def attic_sensitive?
	return true
      end
    end

    class Head < RevFilter
      def parse_log_opts_all
	return ['-N', '-r']
      end

      def revision(rev)
	if @branch
	  if rev.on?(@branch)
	    if @revs.empty?
	      @revs << rev
	      @one = rev
	    else
	      @revs[0] = @one = rev if @one < rev
	    end
	  end
	else
	  if rev.on_trunk?
	    if @revs.empty?
	      @revs << rev
	      @one = rev
	    else
	      @revs[0] = @one = rev if @one < rev
	    end
	  end
	end
      end

      def attic_sensitive?
	return true
      end
    end

    class Tag < RevFilter
      def initialize(tag)
	super()
        @target_tag = tag
      end

      def symbol(sym, rev)
        super
	@target_rev = rev if sym == @target_tag
      end

      def revision(rev)
        if @target_rev
	  if @target_rev.branch?
	    super if rev.on?(@target_rev)
	  else
	    super if rev == @target_rev
	  end
	end
      end
    end

    class Rev < RevFilter
      def initialize(rev)
	super()
        @target_rev = rev
      end

      def parse_log_opts_one
	if @target_rev.branch?
	  return ['-N', "-r#{@target_rev.to_s}:."]
	else
	  return ['-N', "-r#{@target_rev.to_s}"]
	end
      end

      def parse_log_opts_all?(rev)
	return ['-N', "-r#{@target_rev.to_s}"]
      end

      def revision(rev)
	if @target_rev.branch?
	  super if rev.on?(@target_rev)
	else
	  super if rev == @target_rev
	end
      end
    end
  end

  def view_directory
    filter = RevFilter.create(@cgi['only_with_tag'][0])
    opts = filter.parse_log_opts_one

    files = []
    @cvsdir.parse_log(ViewDirectoryVisitor.new(self, @cvsdir, filter, files), opts)
    files.sort! {|a,b| a.name <=> b.name}
    return RSP.load("#{RSP_DIR}/view_directory.rsp").new(
      RSP[
        :directory =>
	  @cvsdir.listdir.sort {|a,b| a.path <=> b.path}.collect {|subdir|
	    RSP[
	      :name => File.basename(subdir.path),
	      :path => subdir.path,
	      :url => url(subdir.path + '/')]},
        :file => files
      ]).gen
  end
  class ViewDirectoryVisitor < CVS::Visitor
    def initialize(reviz, cvsdir, filter, files)
      @reviz = reviz
      @cvsdir = cvsdir
      @filter_orig = filter
      @files = files
    end

    def rcsfile_splitted(dir, file, attic)
      @filter = @filter_orig.dup
      @cvsfile = @cvsdir.file(file, attic)
      @target = nil
      @date = nil
      @author = nil
      @state = nil
      @message = nil
    end

    def head(rev)
      @filter.head(rev)
    end

    def branch(rev)
      @filter.branch(rev)
    end

    def symbol(sym, rev)
      @filter.symbol(sym, rev)
    end

    def delta_without_next(rev, date, author, state, branches)
      @filter.revision(rev)
      if rev == @filter.one
	@target = rev
	@date = date
	@author = author
	@state = state
      end
    end

    def deltatext_log(rev, message)
      if rev == @filter.one
        @message = message
      end
    end

    def finished(buf)
      if @target
	@files << RSP[
	  :name => @cvsfile.name,
	  :path => @cvsfile.path,
	  :url => @reviz.url(@cvsfile.path),
	  :rev => @target,
	  :date => @date,
	  :author => @author,
	  :state => @state,
	  :message => @message,
	  :removed => @state == 'dead' || @filter.attic_sensitive? && @cvsfile.attic

	]
      end
    end
  end

  def view_log
    logs = []
    @cvsfile.parse_log(ViewLogVisitor.new {|args| logs << rsp_log(*args)})
    return RSP.load("#{RSP_DIR}/view_log.rsp").new(
      RSP[
        :logs => logs
      ]).gen
  end
  class ViewLogVisitor < CVS::Visitor
    def initialize(&block)
      @block = block
      @rev2sym = {}
      @rev2sym.default = [].freeze
    end
    def symbol(sym, rev)
      unless @rev2sym.has_key? rev
        @rev2sym[rev] = []
      end
      @rev2sym[rev] << sym
    end
    def delta_rlog(rev, locked_by, date, author, state,
                   add, del, branches, message)
      #p [rev, locked_by, date, author, state, add, del, branches, message]
      @block.call(rev, locked_by, date, author, state,
                  add, del, branches, message, @rev2sym[rev])
    end
  end

  def rsp_log(rev, locked_by, date, author, state,
	  add, del, branches, message, tags)
    RSP[
      :rev => rev.to_s,
      :tags => tags,
      :tagged_urls => Hash[*tags.collect {|tag| [tag, url(@cvsfile.path, {'only_with_tag'=>tag})]}.flatten],
      :checkout_url => url(@cvsfile.path, {'rev'=>rev.to_s}),
      :annotate_url => url(@cvsfile.path, {'annotate'=>rev.to_s}),
      :date => date,
      :author => author,
      :message => message
    ]
  end

  def view_checkout(rev)
    log = nil
    @cvsfile.parse_log(ViewLogVisitor.new {|args| log = rsp_log(*args)},
                       ["-r#{rev.to_s}"])
    contents, attributes = @cvsfile.checkout(rev) {|c, a| [c, a]}
    return RSP.load("#{RSP_DIR}/view_checkout.rsp").new(
      RSP[
	:log => log,
	:contents => contents,
	:attributes => attributes.inspect
      ]).gen

  end

  def view_annotate(rev)
    lines = []
    rev1len = 0
    rev2len = 0
    authorlen = 0
    @cvsfile.fullannotate(rev) {|contents, date1, rev1, author, rev2, date2|
      h = {:contents => contents,
	   :date1 => date1,
	   :rev1 => rev1,
	   :author => author,
	   :rev2 => rev2
      }
      h[:date2] = date2 ? date2 : nil
      h[:nonewline] = /\n\z/ !~ contents
      lines << RSP[h]
      if rev1len < (l = rev1.to_s.length)
	rev1len = l
      end
      if rev2len < (l = rev2.to_s.length)
	rev2len = l
      end
      if authorlen < (l = author.length)
	authorlen = l
      end
    }
    return RSP.load("#{RSP_DIR}/view_annotate.rsp").new(
      RSP[
        :rev1len => rev1len,
        :rev2len => rev2len,
        :authorlen => authorlen,
	:lines => lines
      ]).gen
  end
end

ReViz.new.main
